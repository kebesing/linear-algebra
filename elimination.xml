<?xml version="1.0" encoding="UTF-8" ?>

<!-- This file is part of the workbook                        -->
<!--                                                          -->
<!--    Math 2500: Linear Algebra                             -->
<!--                                                          -->
<!-- Copyright (C) 2014-2016  Theron J. Hitchman              -->
<!-- See the file COPYING for copying conditions.             -->

<section xml:id="elimination">
  <title>Solving Systems</title>

  <subsection>
    <title>The Assignment</title>
    <ul>
      <li>Read section 2.2 of Strang (pages 45-51).</li>
      <li>
        Watch a video or two from the YouTube series <em>Essence of Linear Algebra</em>
        by user <em>3Blue1Brown</em>.
      </li>
      <li>Read the following and complete the exercises below.</li>
    </ul>

  </subsection>

  <subsection>
    <title>Learning Goals</title>
    <p>
      Before class, a student should be able to do the following things.
    </p>
    <ul>
      <li>Clearly state and use the following vocabulary words: pivot, multiplier,
        triangular matrix, back substitution, singular, non-singular
      </li>
    </ul>
    <p>
      Sometime after class, a student should be able to the following things.
    </p>
    <ul>
      <li>Perform elimination to put a system of linear equations into triangular form.</li>
      <li>Solve small systems by hand.</li>
      <li>Explain the two failure modes for elimination, and describe which leads to
        no solutions, and which leads to infinitely many solutions.</li>
      <li>Solve larger systems with the help of a computer algebra package (Sage).</li>
    </ul>

  </subsection>

  <subsection>
    <title>Discussion: Elimination for Solving Systems of Linear Equations</title>
      <p>
        Now we begin the process of learning how to solve a system of linear
        equations systematically through a process called <term>elimination</term>.
      </p>

      <subsubsection>
        <title>Some terminology</title>
        <p>A typical system looks something like this:
          <me>
            \left\{ \begin{array}{rrrrrrrr}
                  3 x_1 &amp; +&amp;  2 x_2 &amp; - &amp; \pi x_3 &amp; = &amp; 0 \\
                  -4 x_1 &amp; -&amp; 33 x_2 &amp; + &amp; x_3 &amp; = &amp; 12
                  \end{array}\right.
          </me>
          This situation is <em>two</em> equations in <em>three</em> unknowns.
          The unknowns here are the three numbers <m>x_1</m>, <m>x_2</m> and
          <m>x_3</m> for which we search. Usually, we bundle the numbers
          together as a vector <m>(x_1, x_2, x_3)</m>. If we can find a vector
          which makes all of the equations true simultaneously, we call that
          vector a <term>solution</term>.
        </p>
        <p>
          Keep in mind that the process involves eliminating instances of the
          variable below <term>pivots</term>. Strang describes the process
          pretty well, and gives good examples. What Strang describes in this
          section is sometimes called <term>the forward pass</term> elimination.
        </p>
        <p>
          Watch out for situations which are <term>singular</term> in that they
          have fewer pivots than unknowns. A system is called
          <term>non-singular</term> if it has as many pivots as unknowns.
        </p>
      </subsubsection>

      <subsubsection>
        <title>Keeping track of things</title>
        <p>
          Playing with all of the equations is nice, but all that really
          matters is the collection of coefficients, and the numbers on the
          right hand sides of the equal signs. Experienced solvers get tired
          of copying notation from line to line in a computation, so they only
          keep track of the matrix of coefficients, <term>augmented</term> by
          the vector on the right-hand side. In the example above, that
          augmented matrix is
          <me>
            \augmatrix{ccc}{
            3 &amp; 2 &amp; -\pi &amp; 0 \\ -4 &amp; -33 &amp; 1 &amp; 12
            }
          </me>
          All of the row operations can be performed on just this augmented
          matrix, without losing any of the essential information.
        </p>
      </subsubsection>
    </subsection>

    <subsection>
      <title>SageMath and Row Operations</title>

      <p>
        The process of elimination for systems of equations involves performing
        operations on the equations. When translated to matrix form, it involves
        operations on the rows of the coefficient matrix. The corresponding
        matrix methods come in two types.
      </p>
      <p>
        The first type of method modifies the matrix <q>in place</q>, which means
        that it <em>Changes the input matrix</em>.
      </p>
      <ul>
        <li><c>A.rescale_row(r, num)</c> multiplies row <c>r</c> by the factor of <c>num</c>.</li>
        <li><c>A.swap_rows(r1, r2)</c> switches the places of rows <c>r1</c> and <c>r2</c>.</li>
        <li><c>A.add_multiple_of_row(target, useful, num)</c>. This adds <c>num</c>
          times row <c>useful</c> to row <c>target</c>.</li>
      </ul>
      <p>
        Throughout, please remember that SageMath uses <m>0</m>-based indexing! So
        the rows are labeled <c>0, 1, 2, ...</c>
      </p>

      <sage>
        <input>
          A = matrix(QQ, 3,3, [0,2,4, 1,1,5, 6,2,5]); A
        </input>
        <output>
          [0 2 4]
          [1 1 5]
          [6 2 5]
        </output>
      </sage>

      <sage>
        <input>
          A.swap_rows(0,1); A
        </input>
        <output>
          [1 1 5]
          [0 2 4]
          [6 2 5]
        </output>
      </sage>

      <sage>
        <input>
          A.add_multiple_of_row(2,0,-6)
          A # this should add -6 times row 0 to row 2
        </input>
        <output>
          [  1   1   5]
          [  0   2   4]
          [  0  -4 -25]
        </output>
      </sage>

      <sage>
        <input>
          A.rescale_row(1,1/2); A
        </input>
        <output>
          [  1   1   5]
          [  0   1   2]
          [  0  -4 -25]
        </output>
      </sage>

      <sage>
        <input>
          A.add_multiple_of_row(2,1,4)
          A # this should add 4 times row 2 to row 2
        </input>
        <output>
          [  1   1   5]
          [  0   1   2]
          [  0   0 -17]
        </output>
      </sage>

      <sage>
        <input>
          A.rescale_row(2,-1/17); A
        </input>
        <output>
          [1 1 5]
          [0 1 2]
          [0 0 1]
        </output>
      </sage>
      <p>
        This just did the whole process of <term>forward pass elimination</term>.
        (Well, we did a bit more than Strang would. He wouldn't rescale the rows.)
      </p>

      <p>
        Sometimes you do not want to change the matrix <c>A</c>. If instead, you
        want to leave <c>A</c> alone, you can use these methods, which return
        a new object and do not change <c>A</c>.
      </p>
      <ul>
        <li><c>A.with_rescaled_row(r, num)</c></li>
        <li><c>A.with_swapped_rows(r1, r2)</c></li>
        <li><c>A.with_added_multiple_of_row(t, u, num)</c></li>
      </ul>
      <p>
        Let's do the same operations as above, but without changing <c>A</c>.
        This will mean making a bunch of new matrices. In fact, let's also change
        the name of our matrix to <c>B</c>.
      </p>

      <sage>
        <input>
          B = matrix(QQ, 3,3, [0,2,4, 1,1,5, 6,2,5]); B
        </input>
        <output>
          [0 2 4]
          [1 1 5]
          [6 2 5]
        </output>
      </sage>

      <sage>
        <input>
          B1 = B.with_swapped_rows(0,1); B1
        </input>
        <output>
          [1 1 5]
          [0 2 4]
          [6 2 5]
        </output>
      </sage>

      <sage>
        <input>
          B2 = B1.with_added_multiple_of_row(2,0,-6)
          B2 # this should add -6 times row 0 to row 2
        </input>
        <output>
          [  1   1   5]
          [  0   2   4]
          [  0  -4 -25]
        </output>
      </sage>

      <sage>
        <input>
          B3 = B2.with_rescaled_row(1,1/2); B3
        </input>
        <output>
          [  1   1   5]
          [  0   1   2]
          [  0  -4 -25]
        </output>
      </sage>

      <sage>
        <input>
          B4 = B3.with_added_multiple_of_row(2,1,4)
          B4 # this should add 4 times row 2 to row 2
        </input>
        <output>
          [  1   1   5]
          [  0   1   2]
          [  0   0 -17]
        </output>
      </sage>

      <sage>
        <input>
          B5 = B4.with_rescaled_row(2,-1/17); B5
        </input>
        <output>
          [1 1 5]
          [0 1 2]
          [0 0 1]
        </output>
      </sage>

      <p>
        This second option has some advantages. At any point, you can revise your
        work, because the original matrix is still in memory, and so are all of
        the intermediate steps. Let's display all six of the matrices at once to
        see that they all still exist.
      </p>

      <sage>
        <input>
          B, B1, B2, B3, B4, B5
        </input>
      </sage>
    </subsection>

<!--
    <subsection>
      <title>Sage Demonstrations</title>

      <demonstration>
        <title>Elimination and the row picture</title>

        <p>In the row picture, elimination steps correspond to changing the family
          of lines (or hyperplanes) without moving the points of intersection.
          In particular, it is useful to get those lines into positions which are
          parallel to the axes of the coordinate system, since this leads to equations
          which are easier to solve.
        </p>
        <p>
          Try choosing a

        <sage>
          <input>

          </input>
        </sage>

      </demonstration>

-->



    <subsection>
      <title>Exercises</title>

      <task>
        <statement>
          Use the elimination method to transform this system into an easier
          one. (Can you make it triangular?) Circle the pivots in the final
          result.
          <me>
            \left\{
            \begin{array}{rrrrrrr}
            2x &amp; + &amp; 3y &amp; + &amp;  z &amp; = &amp; 8\\
            4x &amp; + &amp; 7y &amp; + &amp; 5z &amp; = &amp; 20 \\
               &amp; - &amp; 2y &amp; + &amp; 2z &amp; = &amp; 0
            \end{array}\right.
          </me>
          What two operations do you use to do this efficiently? Now use back
          substitution to solve the system.
        </statement>
      </task>

<!--
      <task>
        <statement>
          <p>
            <em>(SageMath Exercise)</em>:
            Because the last system can be transformed in two operations, there
            are three equivalent systems generated through the process
            (the original, the intermediate, and the final).
          </p>
          <p>
            Make row picture plots for each of the three systems. [Hint: Sage]
            How do the operations transform the pictures?
          </p>
        </statement>
      </task>
-->

      <task>
        <statement>
          Suppose that a system of three equations in three unknowns has two
          solutions <m>(1,0,-1)</m> and <m>(2,1,2)</m>. Explain why the system must have
          other solutions than these two. Describe clearly two other solutions.
        </statement>
      </task>


      <task>
        <statement>
          Find three examples of numbers <m>a</m> so that elimination will fail to
          give three pivots for this coefficient matrix:
          <me>
            A = \begin{pmatrix}
            a &amp; 2 &amp; 3 \\ a &amp; a &amp; 4 \\ a &amp; a &amp; a
            \end{pmatrix}
          </me>
        </statement>
      </task>

      <task>
        <statement>
          Complete the following to make an example of a system of two equations
          in two unknowns which is singular but still has a solution, or explain why
          no such example exists.
          <me>
            \left\{
            \begin{array}{ccccc}
            2x &amp; + &amp; 3y &amp; = &amp; 1 \\
            \bullet x &amp; + &amp; \bullet y &amp; = &amp; \bullet
            \end{array}\right.
          </me>
        </statement>
      </task>


      <task>
        <statement>
          Complete the following to a system of three equations in three
          unknowns which is singular and does not have a solution, or explain
          why no such example exists.
          <me>
            \left\{
            \begin{array}{ccccccc}
               &amp;  &amp; 3y &amp; - &amp; z &amp; = &amp; 1 \\
            2x &amp; - &amp; y &amp; + &amp; 3z &amp; = &amp; 0 \\
            \bullet x &amp; + &amp; \bullet y &amp; + &amp;\bullet z &amp;  = &amp; \bullet
            \end{array}\right.
          </me>
        </statement>
      </task>


      <task>
        <statement>
          Complete the following to a system of three equations in three
          unknowns which is singular but still has a solution, or explain why
          no such example exists.
          <me>
            \left\{
            \begin{array}{ccccccc}
            x &amp; + &amp; y &amp; + &amp; z &amp; = &amp; 1 \\
            2x &amp; + &amp; y &amp; + &amp; 2z &amp; = &amp; 0 \\
            \bullet x &amp; + &amp; \bullet y &amp; + &amp;\bullet z &amp;  = &amp; \bullet
            \end{array}\right.
          </me>
        </statement>
      </task>




      <task>
        <statement>
          <ol>
            <li>
              How many ways can three planes in three dimensional space meet? Make
              examples to represent as many <em>qualitatively different</em>
              situations as you can.
            </li>
            <li>
              How many ways can two lines in the plane meet? Make examples to
              represent as many <em>qualitatively different</em> situations as you can.
            </li>
          </ol>
        </statement>
      </task>



    </subsection>


</section>
